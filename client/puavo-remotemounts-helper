#!/usr/bin/ruby1.9.1

puavo_hosttype = IO.read('/etc/puavo/hosttype').chomp
if puavo_hosttype != 'laptop' then
  exit(0)
end

require 'json'
require 'timeout'

@device = JSON.parse( IO.read('/etc/puavo/device.json') )

def check_mount_state(gvfsmntpath)
  begin
    Timeout::timeout(5) do
      puts "Doing stat for #{ gvfsmntpath }"
      File.stat(gvfsmntpath)
    end
  rescue Errno::ENOENT => e
    return 'not connected'
  rescue Timeout::Error => e
    return 'timeout'
  end

  return 'ok'
end

def errmsg(msg)
  STDERR.puts "puavo-remotemounts-helper: #{ msg }"
end

def timeout_noex(seconds, &code)
  begin
    return Timeout::timeout(seconds, &code)
  rescue Timeout::Error => e
    return false
  end
end

def ensure_mounts_to_remote_directory(gvfsmntpath)
  checks_with_timeout = 0

  while true do
    begin
      case check_mount_state(gvfsmntpath)

        when 'not connected'
          puts "puavo-remotemounts-helper: mounting '#{ gvfsmntpath }'"
          timeout_noex(30) { system('gvfs-mount', gvfsmntpath) } \
            or errmsg "problem in mounting '#{ gvfsmntpath }'"
          checks_with_timeout = 0

        when 'ok'
          checks_with_timeout = 0

        when 'timeout'
          checks_with_timeout += 1
          if checks_with_timeout >= 5 then
            puts "puavo-remotemounts-helper: unmounting '#{ gvfsmntpath }'"
            timeout_noex(30) { system('gvfs-mount', '-u', gvfsmntpath) } \
              or errmsg "problem in unmounting '#{ gvfsmntpath }'"
            checks_with_timeout = 0
          end

      end
    rescue StandardError => e
      errmsg "Got some error: #{ e }, yet continuing..."
    end

    sleep(10)
  end
end

def has_device_tag(tag)
  (@device['tags'] || []).include?(tag)
end

def use_remotemounts
  # Doing the remote mounts is the default,
  # "no_use_remotemounts"-tag will disable that,
  # but then again "use_remotemounts"-tag overrides it.
  ! has_device_tag('no_use_remotemounts') || has_device_tag('use_remotemounts')
end

if !use_remotemounts then
  # Tags suggest we should do nothing.
  exit(0)
end

puavo_domain = IO.read('/etc/puavo/domain').chomp

sharename \
  = case (ENV['LANG'] || '')[0..1]
      when 'fi' 'yhteiset'
      when 'sv' 'delade_filer'
      else      'share'
    end

primary_group = %x(id -gn).chomp
raise('Problem running id -gn') unless $?.exitstatus == 0

raise('No USER environment set') unless ENV['USER'] && !ENV['USER'].empty?

gvfs_mounts = [
  "smb://homedir.#{ puavo_domain }/#{ ENV['USER'] }",
  "smb://homedir.#{ puavo_domain }/share/#{ sharename }/#{ primary_group }",
]

#
# ensure mounts to remote directories come up and stay
#

threads \
  = gvfs_mounts.map do |gvfsmntpath|
      Thread.new { ensure_mounts_to_remote_directory(gvfsmntpath) }
    end

threads.each { |t| t.join }

exit(0)
