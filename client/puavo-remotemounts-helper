#!/usr/bin/ruby1.9.1

puavo_hosttype = IO.read('/etc/puavo/hosttype').chomp
if puavo_hosttype != 'laptop' then
  exit(0)
end

require 'json'
require 'timeout'

@device = JSON.parse( IO.read('/etc/puavo/device.json') )

def errmsg(msg)
  STDERR.puts "puavo-remotemounts-helper: #{ msg }"
end

def has_device_tag(tag)
  (@device['tags'] || []).include?(tag)
end

def timeout_noex(seconds, &code)
  begin
    return Timeout::timeout(seconds, &code)
  rescue Timeout::Error => e
    return false
  end
end

def use_remotemounts
  # Doing the remote mounts is the default,
  # "no_use_remotemounts"-tag will disable that,
  # but then again "use_remotemounts"-tag overrides it.
  ! has_device_tag('no_use_remotemounts') || has_device_tag('use_remotemounts')
end

class GvfsMount
  def initialize(url, mntpath, linkname)
    @linkname = linkname
    @mntpath  = mntpath
    @url      = url
  end

  def check_mount_state(mntpath)
    system('timeout', '-s', 'KILL', '5', 'stat', '-c', '%X', mntpath, \
           { :out => '/dev/null', :err => '/dev/null' })

    return 'timeout' if $?.termsig == 9
    return 'ok'      if $?.exitstatus == 0

    return 'not connected'
  end

  def ensure_mounts
    checks_with_timeout = 0

    while true do
      begin
        mount_state = check_mount_state(@mntpath)
        puts "mount state for #{ @url } is #{ mount_state }"
	case mount_state
	  when 'not connected'
	    puts "puavo-remotemounts-helper: mounting '#{ @mntpath }'"
	    timeout_noex(30) { system('gvfs-mount', @url) } \
	      or errmsg "problem in mounting '#{ @url }'"
	    checks_with_timeout = 0

	  when 'ok'
	    checks_with_timeout = 0

	  when 'timeout'
	    checks_with_timeout += 1
	    if checks_with_timeout >= 5 then
	      puts "puavo-remotemounts-helper: unmounting '#{ @url }'"
	      timeout_noex(30) { system('gvfs-mount', '-u', @url) } \
		or errmsg "problem in unmounting '#{ @url }'"
	      checks_with_timeout = 0
	    end
	end
      rescue StandardError => e
	errmsg "Got some error: #{ e }, yet continuing..."
      end

      sleep(10)
    end
  end
end

def get_our_gvfsmounts
  puavo_domain = IO.read('/etc/puavo/domain').chomp
  sharename \
    = case (ENV['LANG'] || '')[0..1]
	when 'fi' 'yhteiset'
	when 'sv' 'delade_filer'
	else      'share'
      end

  user_primary_group = %x(id -gn).chomp
  raise('Problem running id -gn') unless $?.exitstatus == 0

  raise('No USER environment set') unless ENV['USER'] && !ENV['USER'].empty?

  user_id = Process.uid

  [
    GvfsMount.new(
      "smb://homedir.#{ puavo_domain }/#{ ENV['USER'] }",
      "/run/user/#{ user_id }/gvfs/smb-share:server=homedir.#{ puavo_domain },share=#{ ENV['USER'] }",
      "Verkkohakemisto"),

    GvfsMount.new(
      "smb://homedir.#{ puavo_domain }/share/#{ sharename }/#{ user_primary_group }",
      "/run/user/#{ user_id }/gvfs/smb-share:server=homedir.#{ puavo_domain },share=share/#{ sharename }/#{ user_primary_group }",
      "Yhteiset"),
  ]
end

if !use_remotemounts then
  # Tags suggest we should do nothing.
  exit(0)
end

# ensure mounts to remote directories come up and stay

gvfs_mounts = get_our_gvfsmounts()

threads = gvfs_mounts.map { |gvfsmnt| Thread.new { gvfsmnt.ensure_mounts() } }

threads.each &:join

exit(0)
