#!/usr/bin/ruby1.9.1
# encoding: UTF-8

puavo_hosttype = IO.read('/etc/puavo/hosttype').chomp
if puavo_hosttype != 'laptop' then
  exit(0)
end

exit(0) if ENV['GUEST_SESSION'] == 'true'

require 'dbus'
require 'fileutils'
require 'json'
require 'open3'
require 'resolv'
require 'thread'

@device = JSON.parse( IO.read('/etc/puavo/device.json') )
$puavo_domain = IO.read('/etc/puavo/domain').chomp

$update_gtk_bookmarks_semaphore = Mutex.new

def log(msg)
  STDERR.puts("puavo-remotemounts-helper #{ Time.now }: #{ msg }")
end

def has_device_tag(tag)
  (@device['tags'] || []).include?(tag)
end

def use_remotemounts
  # Doing the remote mounts is the default,
  # "no_use_remotemounts"-tag will disable that,
  # but then again "use_remotemounts"-tag overrides it.
  ! has_device_tag('no_use_remotemounts') || has_device_tag('use_remotemounts')
end

class DbusHandler
  def initialize(gvfs_mounts)
    @gvfs_mounts = gvfs_mounts

    @active_connection_count = 0
    @in_sleep = false

    bus = DBus::SystemBus.instance

    loginservice = bus.service('org.freedesktop.login1')
    loginobj = loginservice.object('/org/freedesktop/login1')
    loginobj.introspect
    loginobj.default_iface = 'org.freedesktop.login1.Manager'

    # if we are going to suspend, deactivate gvfs-mounts

    loginobj.on_signal('PrepareForSleep') do |preparing_for_sleep|
      log('received PrepareForSleep-dbus-signal, preparing for sleep')
      @in_sleep = preparing_for_sleep
      activate_or_deactivate
    end

    # if we have no active network connections, deactivate gvfs-mounts

    nmservice = bus.service('org.freedesktop.NetworkManager')
    nmobj = nmservice.object('/org/freedesktop/NetworkManager')
    nmobj.introspect
    nmobj.default_iface = 'org.freedesktop.NetworkManager'

    @active_connection_count \
      = nmobj['org.freedesktop.NetworkManager']['ActiveConnections'].count

    nmobj.on_signal('PropertiesChanged') do |props|
      log('received PropertiesChanged-dbus-signal')
      if props['ActiveConnections'].kind_of?(Array) then
        @active_connection_count = props['ActiveConnections'].count
        log("active connection count is #{ @active_connection_count }")
        activate_or_deactivate
      end
    end

    activate_or_deactivate

    log('starting up dbus handler')

    loop = DBus::Main.new
    loop << bus
    loop.run
  end

  def activate_or_deactivate
    method = !@in_sleep && (@active_connection_count > 0) \
                ? :activate                               \
                : :deactivate

    if method == :activate then
      log('activating remote mounts')
    else
      log('deactivating remote mounts')
    end

    @gvfs_mounts.each { |gvfsmount| gvfsmount.send(method) }
  end
end

class GvfsMount
  attr_reader :linkname

  def initialize(remote_path, user_id, linkname)
    @active      = true
    @linkname    = linkname
    @remote_path = remote_path
    @user_id     = user_id

    @mntpath     = nil
    @remote_host = nil
    @url         = nil

    @previous_mount_state = nil
  end

  def activate()
    @active = true
  end

  def deactivate()
    @active = false
    unmount_gvfsmount()
  end

  def check_mount_state()
    # returns 'no mountpoint known', 'not connected', 'ok' or 'timeout'

    return 'no mountpoint known' unless @mntpath

    # wait for 10 seconds for stat operation to a remote path
    system('timeout', '-s', 'KILL', '10', 'stat', '-c', '%X', @mntpath, \
           { :out => '/dev/null', :err => '/dev/null' })

    return 'timeout' if $?.termsig == 9
    return 'ok'      if $?.exitstatus == 0

    # if stat fails, check explicitly with gvfs-mount if mount exists

    output, s = Open3.capture2e('gvfs-mount', '-il')
    raise "gvfs-mount -il returned error code #{ s.exitstatus }" \
      unless s.exitstatus == 0

    re = /^\s+default_location=#{ Regexp.quote(@url) }$/
    output.split("\n").each do |line|
      return 'ok' if line.match(re)
    end

    return 'not connected'
  end

  def ensure_link(shouldbe)
    begin
      linksrc = "#{ ENV['HOME'] }/#{ @linkname }"

      if shouldbe; then
        return unless @mntpath
        begin
          return if File.readlink(linksrc) == @mntpath
        rescue Errno::ENOENT
        end
        log("adding link from '#{ linksrc }' to '#{ @mntpath }'")
        FileUtils.rm_f(linksrc)
        FileUtils.symlink(@mntpath, linksrc)
      else
        log("removing link '#{ linksrc }'") if File.symlink?(linksrc)
        FileUtils.rm_f(linksrc)
      end

      # Update bookmarks when links have changed.
      # Use a mutex so that threads do not run this at the same time.
      $update_gtk_bookmarks_semaphore.synchronize do
        log('running puavo-update-gtk-bookmarks')
        system('puavo-update-gtk-bookmarks')
      end
    rescue StandardError => e
      log("error in ensure_link(): #{ e.message }")
      raise e
    end
  end

  def check_and_handle_mount(checks_with_timeout)
    mount_state = check_mount_state()

    if mount_state != @previous_mount_state then
      log("mount state changed to '#{ mount_state }'")
      @previous_mount_state = mount_state
    end

    if !@active then
      if mount_state != 'not connected' then
        unmount_gvfsmount()
        checks_with_timeout[0] = 0
      end

      return
    end

    case mount_state
      when 'no mountpoint known'
        # do nothing
      when 'not connected'
        ensure_link(false) rescue true
        begin
          # make sure dns works, so we do not stress gvfs-mount,
          # besides, it is not an error if gvfs-mount fails if not
          # on the right network
          Resolv::DNS.new.getaddress(@remote_host)

          log("mounting '#{ @mntpath }'")
          system('timeout', '-k', '10', '20', 'gvfs-mount', @url) \
            or log("problem in mounting '#{ @url }'")
          checks_with_timeout[0] = 0
        rescue Resolv::ResolvError
          log("did not find #{ @remote_host }, not mounting #{ @url }")
        end

      when 'ok'
        ensure_link(true) rescue true
        checks_with_timeout[0] = 0

      when 'timeout'
        checks_with_timeout[0] += 1
        if checks_with_timeout[0] >= 3 then
          log("got three timeouts in a row, unmounting '#{ @mntpath }'")
          unmount_gvfsmount()
          checks_with_timeout[0] = 0
        end
    end
  end

  def ensure_mount
    checks_with_timeout = [0]

    while true do
      begin
        update_mountinfo_from_dns()
        if @url then
          check_and_handle_mount(checks_with_timeout)
        end

      rescue StandardError => e
        log("got some error: #{ e }, yet continuing...")
      end

      sleep(5)
    end
  end

  def unmount_gvfsmount()
    ensure_link(false) rescue true
    return unless @url
    log("unmounting '#{ @url }'")
    system('timeout', '-k', '5', '10', 'gvfs-mount', '-u', @url) \
      or log("problem in unmounting '#{ @url }'")
  end

  def update_mountinfo_from_dns()
    # If we are behind some server that provides samba mounts for us,
    # update our mount information.

    remote_host = nil
    Resolv::DNS.open do |dns|
      dns.getresources("_sambaserver._tcp.#{ $puavo_domain }",
                       Resolv::DNS::Resource::IN::SRV).each do |srv|
        if srv.port == 139 then
          remote_host = srv.target
          break
        end
      end
    end

    # Use the old info from DNS (if it exists) if we do not get new info.
    # Usually this should result in unmounts soon.
    return if remote_host.nil?

    new_url = "smb://#{ remote_host }/#{ @remote_path }/"

    if @url && @url != new_url then
      log("remote url has changed from '#{ @url }' to '#{ new_url }'," \
            + " unmounting '#{ @mntpath }")
      unmount_gvfsmount()
    end

    @mntpath     = "/run/user/#{ @user_id }/gvfs/smb-share:server=" \
                     + "#{ remote_host },share=#{ @remote_path }"
    @remote_host = remote_host
    @url         = new_url

    log("new server found for mounting '#{ @mntpath }' from '#{ @url }'")
  end
end

def get_our_gvfsmounts
  sharenames = {
    'fi' => 'yhteiset',
    'sv' => 'delade_filer',
    'en' => 'share',
  }

  userdir_labels = {
    'fi' => 'Verkkokansio',
    'sv' => 'NÃ¤tverksmapp',
    'en' => 'Network folder',
  }

  schooldir_labels = {
    'fi' => 'Yhteiset',
    'sv' => 'Delade filer',
    'en' => 'Share',
  }

  lang = (ENV['LANG'] || '')[0..1]

  sharename       = sharenames[lang]       || sharenames['en']
  userdir_label   = userdir_labels[lang]   || userdir_labels['en']
  schooldir_label = schooldir_labels[lang] || schooldir_labels['en']

  user = Etc.getpwuid.name
  user_id = Process.uid
  user_primary_group = Etc.getgrgid( Etc.getpwuid.gid ).name

  [
    GvfsMount.new(user, user_id, userdir_label),
    GvfsMount.new("share/#{ sharename }/#{ user_primary_group }",
                  user_id,
                  schooldir_label)
  ]
end

if !use_remotemounts then
  log('remotemounts disabled due to device tag settings')
  exit(0)
end

# ensure mounts to remote directories come up and stay

gvfs_mounts = get_our_gvfsmounts()

gvfs_threads = gvfs_mounts.map do |gvfsmnt|
                 Thread.new do
                   log("starting a thread to handle '#{ gvfsmnt.linkname }'")
                   gvfsmnt.ensure_mount()
                 end
               end

# we want to run this as long as the gvfs_threads are running
Thread.new do
  begin
    DbusHandler.new(gvfs_mounts)
  rescue StandardError => e
    log("error when starting up dbushandler: #{ e.message }")
    exit 1
  end
end

gvfs_threads.each &:join

exit(0)
