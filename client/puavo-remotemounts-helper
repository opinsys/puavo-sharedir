#!/usr/bin/ruby
# encoding: UTF-8

exit(0) if ENV['GUEST_SESSION'] == 'true'

require 'puavo/conf'

puavoconf = Puavo::Conf.new
exit(0) unless puavoconf.get('puavo.mounts.by_user_from_bootserver.enabled') == 'true'

require 'dbus'
require 'fileutils'
require 'open3'
require 'resolv'
require 'thread'

$puavo_domain = IO.read('/etc/puavo/domain').chomp

$update_gtk_bookmarks_semaphore = Mutex.new

def sendmsg(channel, msg)
  channel.puts "puavo-remotemounts-helper #{ Time.now }: #{ msg }"
end

def errmsg(msg); sendmsg(STDERR, msg); end
def outmsg(msg); sendmsg(STDOUT, msg); end

class DbusHandler
  def initialize(gvfs_mounts)
    @gvfs_mounts = gvfs_mounts

    @active_connection_count = 0
    @in_sleep = false

    bus = DBus::SystemBus.instance

    # if we are going to suspend, deactivate gvfs-mounts

    loginservice = bus.service('org.freedesktop.login1')
    loginobj = loginservice.object('/org/freedesktop/login1')
    loginobj.introspect
    loginobj.default_iface = 'org.freedesktop.login1.Manager'

    loginobj.on_signal('PrepareForSleep') do |preparing_for_sleep|
      @in_sleep = preparing_for_sleep
      activate_or_deactivate
    end

    # if we have no active network connections, deactivate gvfs-mounts

    nmservice = bus.service('org.freedesktop.NetworkManager')
    nmobj = nmservice.object('/org/freedesktop/NetworkManager')
    nmobj.introspect
    nmobj.default_iface = 'org.freedesktop.NetworkManager'

    @active_connection_count \
      = nmobj['org.freedesktop.NetworkManager']['ActiveConnections'].count

    nmobj.on_signal('PropertiesChanged') do |props|
      if props['ActiveConnections'].kind_of?(Array) then
        @active_connection_count = props['ActiveConnections'].count
        activate_or_deactivate
      end
    end

    activate_or_deactivate

    loop = DBus::Main.new
    loop << bus
    loop.run
  end

  def activate_or_deactivate
    method = !@in_sleep && (@active_connection_count > 0) \
                ? :activate                               \
                : :deactivate

    @gvfs_mounts.each { |gvfsmount| gvfsmount.send(method) }
  end
end

class GvfsMount
  def initialize(remote_path, user_id, linkname)
    @active      = true
    @linkname    = linkname
    @remote_path = remote_path
    @user_id     = user_id

    @mntpath     = nil
    @remote_host = nil
    @url         = nil
  end

  def activate()
    @active = true
  end

  def deactivate()
    @active = false
    unmount_gvfsmount()
  end

  def check_mount_state()
    # returns 'not connected', 'ok' or 'timeout'

    # wait for 5 seconds for stat operation to a remote path
    system('timeout', '-s', 'KILL', '5', 'stat', '-c', '%X', @mntpath, \
           { :out => '/dev/null', :err => '/dev/null' })

    return 'timeout' if $?.termsig == 9
    return 'ok'      if $?.exitstatus == 0

    # if stat fails, check explicitly with gvfs-mount if mount exists

    output, s = Open3.capture2e('gvfs-mount', '-il')
    raise "gvfs-mount -il returned error code #{ s.exitstatus }" \
      unless s.exitstatus == 0

    re = /^\s+default_location=#{ Regexp.quote(@url) }$/
    output.split("\n").each do |line|
      return 'ok' if line.match(re)
    end

    return 'not connected'
  end

  def ensure_link(shouldbe)
    begin
      linksrc = "#{ ENV['HOME'] }/#{ @linkname }"

      if shouldbe; then
        begin
          return if File.readlink(linksrc) == @mntpath
        rescue Errno::ENOENT
        end
        FileUtils.rm_f(linksrc)
        FileUtils.symlink(@mntpath, linksrc)
      else
        return unless File.exists?(linksrc)
        FileUtils.rm_f(linksrc)
      end

      # Update bookmarks when links have changed.
      # Use a mutex so that threads do not run this at the same time.
      $update_gtk_bookmarks_semaphore.synchronize do
        system('puavo-update-gtk-bookmarks')
      end
    rescue StandardError => e
      errmsg("Error in ensure_link(): #{ e.message }")
      raise e
    end
  end

  def check_and_handle_mount(checks_with_timeout)
    mount_state = check_mount_state()

    if !@active then
      if mount_state != 'not connected' then
        unmount_gvfsmount()
        checks_with_timeout[0] = 0
      end

      return
    end

    case mount_state
      when 'not connected'
        ensure_link(false) rescue true
        begin
          # make sure dns works, so we do not stress gvfs-mount,
          # besides, it is not an error if gvfs-mount fails if not
          # on the right network
          Resolv::DNS.new.getaddress(@remote_host)

          outmsg("mounting '#{ @mntpath }'")
          system('timeout', '-k', '10', '20', 'gvfs-mount', @url) \
            or errmsg("problem in mounting '#{ @url }'")
          checks_with_timeout[0] = 0
        rescue Resolv::ResolvError
          outmsg("did not find #{ @remote_host }," \
                   + " not mounting #{ @url }")
        end

      when 'ok'
        ensure_link(true) rescue true
        checks_with_timeout[0] = 0

      when 'timeout'
        checks_with_timeout[0] += 1
        if checks_with_timeout[0] >= 3 then
          # with three timeouts in a row, unmount the thing!
          unmount_gvfsmount()
          checks_with_timeout[0] = 0
        end
    end
  end

  def ensure_mount
    checks_with_timeout = [0]

    while true do
      begin
        update_mountinfo_from_dns()
        if @url then
          check_and_handle_mount(checks_with_timeout)
        end

      rescue StandardError => e
        errmsg("Got some error: #{ e }, yet continuing...")
      end

      sleep(5)
    end
  end

  def unmount_gvfsmount()
    ensure_link(false) rescue true
    outmsg("unmounting '#{ @url }'")
    system('timeout', '-k', '5', '10', 'gvfs-mount', '-u', @url) \
      or errmsg("problem in unmounting '#{ @url }'")
  end

  def update_mountinfo_from_dns()
    # If we are behind some server that provides samba mounts for us,
    # update our mount information.

    remote_host = nil
    Resolv::DNS.open do |dns|
      dns.getresources("_sambaserver._tcp.#{ $puavo_domain }",
                       Resolv::DNS::Resource::IN::SRV).each do |srv|
        if srv.port == 139 then
          remote_host = srv.target
          break
        end
      end
    end

    # Use the old info from DNS (if it exists) if we do not get new info.
    # Usually this should result in unmounts soon.
    return if remote_host.nil?

    new_url = "smb://#{ remote_host }/#{ @remote_path }/"

    if @url && @url != new_url then
      unmount_gvfsmount()
    end

    @mntpath     = "/run/user/#{ @user_id }/gvfs/smb-share:server=#{ remote_host },share=#{ @remote_path }"
    @remote_host = remote_host
    @url         = new_url
  end
end

def get_our_gvfsmounts
  sharenames = {
    'fi' => 'yhteiset',
    'sv' => 'delade_filer',
    'en' => 'share',
  }

  userdir_labels = {
    'fi' => 'Verkkokansio',
    'sv' => 'NÃ¤tverksmapp',
    'en' => 'Network folder',
  }

  schooldir_labels = {
    'fi' => 'Yhteiset',
    'sv' => 'Delade filer',
    'en' => 'Share',
  }

  lang = (ENV['LANG'] || '')[0..1]

  sharename       = sharenames[lang]       || sharenames['en']
  userdir_label   = userdir_labels[lang]   || userdir_labels['en']
  schooldir_label = schooldir_labels[lang] || schooldir_labels['en']

  user = Etc.getpwuid.name
  user_id = Process.uid
  user_primary_group = Etc.getgrgid( Etc.getpwuid.gid ).name

  [
    GvfsMount.new(user, user_id, userdir_label),
    GvfsMount.new("share/#{ sharename }/#{ user_primary_group }",
                  user_id,
                  schooldir_label)
  ]
end

# ensure mounts to remote directories come up and stay

gvfs_mounts = get_our_gvfsmounts()

gvfs_threads = gvfs_mounts.map do |gvfsmnt|
                 Thread.new { gvfsmnt.ensure_mount() }
               end

# we want to run this as long as the gvfs_threads are running
Thread.new do
  begin
    DbusHandler.new(gvfs_mounts)
  rescue StandardError => e
    warn e.message
    exit 1
  end
end

gvfs_threads.each &:join

exit(0)
