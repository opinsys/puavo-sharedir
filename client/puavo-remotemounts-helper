#!/usr/bin/ruby1.9.1

puavo_hosttype = IO.read('/etc/puavo/hosttype').chomp
if puavo_hosttype != 'laptop' then
  exit(0)
end

require 'fileutils'
require 'json'
require 'timeout'

@device = JSON.parse( IO.read('/etc/puavo/device.json') )

def errmsg(msg)
  STDERR.puts "puavo-remotemounts-helper: #{ msg }"
end

def has_device_tag(tag)
  (@device['tags'] || []).include?(tag)
end

def timeout_noex(seconds, &code)
  begin
    return Timeout::timeout(seconds, &code)
  rescue Timeout::Error => e
    return false
  end
end

def use_remotemounts
  # Doing the remote mounts is the default,
  # "no_use_remotemounts"-tag will disable that,
  # but then again "use_remotemounts"-tag overrides it.
  ! has_device_tag('no_use_remotemounts') || has_device_tag('use_remotemounts')
end

class GvfsMount
  def initialize(url, mntpath, linkname)
    @linkname = linkname
    @mntpath  = mntpath
    @url      = url
  end

  def check_mount_state(mntpath)
    system('timeout', '-s', 'KILL', '5', 'stat', '-c', '%X', mntpath, \
           { :out => '/dev/null', :err => '/dev/null' })

    return 'timeout' if $?.termsig == 9
    return 'ok'      if $?.exitstatus == 0

    return 'not connected'
  end

  def ensure_link(shouldbe)
    linksrc = "#{ ENV['HOME'] }/#{ @linkname }"

    if shouldbe; then
      system('ln', '-fns', @mntpath, linksrc) \
        or errmsg("Could not create a link from '#{ linksrc }' to" \
                    + " '#{ @mntpath }'")
    else
      FileUtils.rm_f(linksrc)
    end
  end

  def ensure_mounts
    checks_with_timeout = 0

    while true do
      begin
        mount_state = check_mount_state(@mntpath)

	case mount_state
	  when 'not connected'
            ensure_link(false) rescue true
	    puts "puavo-remotemounts-helper: mounting '#{ @mntpath }'"
	    timeout_noex(30) { system('gvfs-mount', @url) } \
	      or errmsg "problem in mounting '#{ @url }'"
	    checks_with_timeout = 0

	  when 'ok'
            ensure_link(true) rescue true
	    checks_with_timeout = 0

	  when 'timeout'
	    checks_with_timeout += 1
	    if checks_with_timeout >= 5 then
              ensure_link(false) rescue true
	      puts "puavo-remotemounts-helper: unmounting '#{ @url }'"
	      timeout_noex(30) { system('gvfs-mount', '-u', @url) } \
		or errmsg "problem in unmounting '#{ @url }'"
	      checks_with_timeout = 0
	    end

	end
      rescue StandardError => e
	errmsg "Got some error: #{ e }, yet continuing..."
      end

      sleep(10)
    end
  end
end

def get_our_gvfsmounts
  puavo_domain = IO.read('/etc/puavo/domain').chomp

  lang = (ENV['LANG'] || '')[0..1]

  sharename \
    = case lang
	when 'fi'; 'yhteiset'
	when 'sv'; 'delade_filer'
	else       'share'
      end

  userdir_displayname \
    = case lang
	when 'fi'; 'Verkkokansio'
	# when 'sv' 'NÃ¤tverksmapp'; # XXX encoding!!
	else       'Network folder'
      end

  schooldir_displayname \
    = case lang
        when 'fi'; 'Yhteiset'
        when 'sv'; 'Delade Filer'
        else       'Share'
      end

  puts "schooldir_displayname=#{ schooldir_displayname } lang=#{ lang }"

  user = Etc.getpwuid.name
  user_id = Process.uid
  user_primary_group = Etc.getgrgid( Etc.getpwuid.gid ).name

  [
    GvfsMount.new(
      "smb://homedir.#{ puavo_domain }/#{ user }",
      "/run/user/#{ user_id }/gvfs/smb-share:server=homedir.#{ puavo_domain },share=#{ user }",
      userdir_displayname),

    GvfsMount.new(
      "smb://homedir.#{ puavo_domain }/share/#{ sharename }/#{ user_primary_group }",
      "/run/user/#{ user_id }/gvfs/smb-share:server=homedir.#{ puavo_domain },share=share/#{ sharename }/#{ user_primary_group }",
      schooldir_displayname),
  ]
end

if !use_remotemounts then
  # Tags suggest we should do nothing.
  exit(0)
end

# ensure mounts to remote directories come up and stay

gvfs_mounts = get_our_gvfsmounts()

threads = gvfs_mounts.map { |gvfsmnt| Thread.new { gvfsmnt.ensure_mounts() } }

threads.each &:join

exit(0)
